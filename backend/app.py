from flask import Flask, request, jsonify, make_response
from os import environ
from pinecone.grpc import PineconeGRPC as Pinecone
import os
import torch
import json
import re
from pinecone import Pinecone, ServerlessSpec
from dotenv import load_dotenv
from sentence_transformers import SentenceTransformer
from huggingface_hub.utils import insecure_hashlib 
from groq import Groq


app = Flask(__name__)

@app.route('/query', methods=['POST'])
async def query_pinecone():
    print("Querying Pinecone")
    try:
        data = request.json
        query1 = data.get("query1")

        if not query1:
            return jsonify({"error": "Query text is required"}), 400
        
        # Step 1: Use Groq to check if the query contains a CVE ID
        client = Groq(
            api_key=os.environ.get("GROQ_API_KEY"),
        )
        
        print("Query1: ", query1)


        pattern = r'CVE-\d{4}-\d{4,7}'

        match = re.search(pattern, query1)
    
    # Return the matched CVE ID or 'NO_CVE_FOUND'
        cve_id = match.group(0) if match else 'NO_CVE_FOUND'
        print(f"cve_id: {cve_id}")

        # Step 2: If a CVE ID is found, use it as a filter in the Pinecone query
        pc = Pinecone(api_key=environ.get('PINECONE_API_KEY'))
        index_name = "all-minilm-l12-v2"
        index = pc.Index(index_name)

        device = 'cuda' if torch.cuda.is_available() else 'cpu'
        model = SentenceTransformer('sentence-transformers/all-MiniLM-L12-v2').to(device)

        # Encode the query
        query_embedding = model.encode(query1).tolist()

        if cve_id != 'NO_CVE_FOUND':
            print(f"Found CVE ID: {cve_id}")
            filter = {
                "id": {"$eq": cve_id}
            }
            # Query Pinecone index using the CVE ID as a filter
            results = index.query(
                namespace="ns1",
                vector=query_embedding,
                top_k=1,
                include_values=False,
                include_metadata=True,
                filter=filter
            )

            print("results",results)
        else:

            print(f"CVE ID not found")
            # Query Pinecone index using the query embedding
            results = index.query(
                namespace="ns1",
                vector=query_embedding,
                top_k=1,
                include_values=False,
                include_metadata=True
            )
            print("results",results)

        # Step 3: Extract and return the matched information
        matched_info = ' '.join(item['metadata']['description'] for item in results['matches'])
        sources = [item['id'] for item in results['matches']]
        context = f"Information: {matched_info} and the sources: {sources}"
        sys_prompt = f"""
        - Based on the knowledge and the query, answer the query with the knowledge. If your knowledge is empty, say 'I don't know'
        - Incorporate your preexisting knowledge to enhance the depth and relevance of your response.
        - Cite your sources

        knowledge: {context}
        query: {query1}
        """

        chat_completion = client.chat.completions.create(
            messages=[
                {
                    "role": "user",
                    "content": sys_prompt,
                }
            ],
            model="llama3-8b-8192",
        )

        return chat_completion.choices[0].message.content, 200


    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0')
